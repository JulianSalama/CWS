
package controllers.lib

import java.io.{File, FileWriter, FileInputStream, FileOutputStream, InputStream, OutputStream}
import scala.collection.mutable.ListBuffer

import org.apache.commons.io.FileUtils

import com.neota.nls.util.Random
import models.Configuration


abstract class BaseTempFile {
  def file: File

  def delete {
    file.delete
  }

  override def toString = file.toString
}

// A tempfile that is deleted when the current request completes.
class RequestScopedTempFile(override val file: File) extends BaseTempFile

// A tempfile that is deleted when the current WebSession expires, or manually.
class SessionScopedTempFile(val tempFileData: models.TempFile) extends BaseTempFile {
  def id = tempFileData.id

  private var _file: File = null
  override def file: File = { synchronized { 
    if (null == _file) {
      _file = TempFiles.createRequestScopedTempFile(tempFileData.prefix, tempFileData.suffix).file
      FileUtils.writeByteArrayToFile(_file, tempFileData.blob)
    }
    _file
  } }

  override def delete {
    models.TempFile.delete(tempFileData)
    if (null != _file)
      _file.delete
  }
}

// A tempfile that is deleted when the current Play! application shuts down, or on the next start if the JVM gets killed.
class ApplicationScopedTempFile(override val file: File) extends BaseTempFile


object TempFiles {
  
  def createRequestScopedTempFile(prefix: String, suffix: String): RequestScopedTempFile = {
    if (null == Current.obj.request)
      throw new Exception("Error: call to createRequestScopedTempFile() outside of WithRequest.")
    val f = new RequestScopedTempFile(createGenericTempFile(prefix, suffix))
    Current.obj.request.addRequestScopedTempFiles(f)
    f
  }

  def deleteRequestScopedTempFiles {
    val r = Current.obj.request
    if (null != r && r.hasRequestScopedTempFiles) {
      for (f <- r.requestScopedTempFiles)
        f.file.delete
    }
  }


  def createSessionScopedTempFile(prefix: String, suffix: String, contents: String): SessionScopedTempFile = {
    createSessionScopedTempFile(prefix, suffix, contents.getBytes)
  }

  def createSessionScopedTempFile(prefix: String, suffix: String, contents: Array[Byte]): SessionScopedTempFile = {
    if (null == Current.obj.webSession)
      throw new Exception("Error: call to createSessionScopedTempFile() outside of WithWebSession.")
    new SessionScopedTempFile(models.TempFile.create(Current.obj.webSession, prefix, suffix, contents))
  }

  def getSessionScopedTempFile(id: Long): Option[SessionScopedTempFile] = models.TempFile.findByID(id) match {
    case Some(tf) => Some(new SessionScopedTempFile(tf))
    case None => None
  }


  def createApplicationScopedTempFile(prefix: String, suffix: String): ApplicationScopedTempFile = { synchronized {
    val f = createGenericTempFile(prefix, suffix)
    val wr = new FileWriter(registryFile)
    wr.write("%s,%s\n".format(aRandomIDForThisCurrentJVMProcess, f.getAbsolutePath))
    wr.close
    new ApplicationScopedTempFile(f)
  } }

  def deleteApplicationScopedTempFiles(all: Boolean = false) { synchronized {
    if (registryFile.exists) {
      val lines = ListBuffer[String]()
      val it = FileUtils.lineIterator(registryFile)
      try {
        while (it.hasNext) {
          val ts = it.nextLine.split(""",""")
          if (ts.size >= 2) {
            if (all || ts(0) != aRandomIDForThisCurrentJVMProcess)
              new File(ts(1)).delete
            else
              lines.append("%s,%s\n".format(ts(0), ts(1)))
          }
        }
      }
      finally {
        it.close
      }

      registryFile.delete
      if (!lines.isEmpty) {
        val wr = new FileWriter(registryFile)
        for (l <- lines)
          wr.write(l)
        wr.close
      }
    }
  } }


  def tempDir: File = {
    val dir = System.getProperty("java.io.tmpdir")
    if (null == dir)
      throw new Exception("Serious misconfiguration: java.io.tmpdir is null.")
    val f = new File("%s%sNeotaLogicServer".format(dir, File.separator))
    f.mkdir
    f
  }

  def sharedFileDir: File = {
    val errmsg = "Shared File directory is not configured, contact your administrator."
    val default = "./data/files"
    val s = Configuration.getConfigurationValue("nls.sharedfiledir", default)
    val sfdir = new File(s)
    if (Configuration.isInCluster) {
      if (s == default) { // must be defined by admin
        throw new NLSException(errmsg, nice=true)
      }
    } else {
      if (s == default && !sfdir.exists) { // create directory if not cluster and is default
        sfdir.mkdirs
      }
    }
    if (!sfdir.exists) {
      throw new NLSException(errmsg, nice=true)
    }
    // can we write
    try {
      val tf = new File(sfdir, "emptytest.txt")
      tf.createNewFile
      tf.delete
    } catch {
      case _: Throwable => throw new NLSException("Cannot write to shared file directory, contact your administrator.", nice=true)
    }
    sfdir
  }

  def userFileDir(uid: Long): File = {
    var ufdir = new File(sharedFileDir, "UserFiles")
    ufdir = new File(ufdir, "%s".format(uid))
    ufdir.mkdirs
    ufdir
  }

  def userFile(uid: Long, fname: String, create: Boolean = false): File = {
    val ufdir = userFileDir(uid)
    if (create) {
      val dotpos = fname.lastIndexOf(".")
      var (prefix, suffix) = if (dotpos >= 0) {
        (fname.substring(0, dotpos), fname.substring(dotpos))
      } else {
        (fname, "")
      }
      while (prefix.size < 3) prefix += com.neota.nls.util.Random.string(1)
      prefix += "_"
      File.createTempFile(prefix, suffix, ufdir)
    } else {
      new File(ufdir, fname)
    }
  }

  def userFileDelete(uid: Long, fname: String) {
    val ufdir = userFileDir(uid)
    var f = new File(ufdir, fname)
    if (f.exists) deleteDir(f)
  }


  /* Deprecated (mime data into files)
  // NDS support for mime data

  def ndsDir(tableID: Long, fieldID: Long): File = {
    var tfdir = new File(sharedFileDir, "NDS")
    tfdir = new File(tfdir, "%s".format(tableID))
    tfdir = new File(tfdir, "%s".format(fieldID))
    tfdir.mkdirs
    tfdir
  }

  def ndsMimeValueFile(tableID: Long, fieldID: Long, fname: String = null): File = {
    val tfdir = ndsDir(tableID, fieldID)
    if (fname != null) {
      new File(tfdir, fname)
    } else {
      File.createTempFile("ndsmv", null, tfdir)
    }
  }

  def ndsDelete(tableID: Long, fieldID: Long) {
    // delete the files for this NDS Field
    { try { Some(ndsDir(tableID, fieldID)) }
      catch {
        case e: NLSException => None
      }
   } match {
     case Some(tfdir) => deleteDir(tfdir)
     case None =>
   }
  }

  def ndsDeleteFile(tableID: Long, fieldID: Long, fname: String) {
    val f = ndsMimeValueFile(tableID, fieldID, fname)
    if (f.exists) f.delete
  }
  */

  // NDS import support

  def ndsTempFile(prefix: String, suffix: String): File = {
    var tfdir = new File(sharedFileDir, "NDS")
    tfdir = new File(tfdir, "tmp")
    tfdir.mkdirs
    File.createTempFile(prefix, suffix, tfdir)
  }

  def ndsTempFileByName(fname: String): File = {
    var tfdir = new File(sharedFileDir, "NDS")
    tfdir = new File(tfdir, "tmp")
    tfdir.mkdirs
    new File(tfdir, fname)
  }

  def purgeOldNDSTempFiles {
    val now = new java.util.Date().getTime
    var tfdir = new File(sharedFileDir, "NDS")
    tfdir = new File(tfdir, "tmp")
    val fileList = tfdir.list
    if (null != fileList) {
      fileList.foreach(fname => {
        val tf = new File(tfdir, fname)
        if (((now - tf.lastModified) / 1000 / 60 / 60) > 2 ) {
          tf.delete
        }
      })
    }
  }

  // End NDS support

  /*
  def runtimeSessionDir(rsid: Long): File = {
    var rsdir = new File(sharedFileDir, "RuntimeSession")
    rsdir = new File(rsdir, "%s".format(rsid))
    rsdir.mkdirs
    rsdir
  }

  def runtimeSessionMimeValueFile(rsid: Long, fname: String = null): File = {
    val rsdir = runtimeSessionDir(rsid)
    if (fname != null) {
      new File(rsdir, fname)
    } else {
      File.createTempFile("rsmv", null, rsdir)
    }
  }

  def runtimeSessionMimeValueFiles(rsid: Long): List[String] = {
    val rsdir = runtimeSessionDir(rsid)
    rsdir.list.toList
  }

  def runtimeSessionCopy(fromid: Long, toid: Long) {
    val rsdirfrom = runtimeSessionDir(fromid)
    val rsdirto = runtimeSessionDir(toid)
    for (fname <- rsdirfrom.list) {
      val fromf = new File(rsdirfrom, fname)
      val tof = new File(rsdirto, fname)
      copyFile(fromf, tof)
    }
  }

  def runtimeSessionDelete(id: Long) {
    // delete the files for this runtime session
    {
      // FIX: would be better to be able to tell if the directory is configured, rather than swallow an exception.
      // But either way, don't barf here if temp files are set up.
      try {
        Some(runtimeSessionDir(id))
      }
      catch {
        case e: NLSException => None
      }
    } match {
      case Some(rsdir) => deleteDir(rsdir)
      case None =>
    }
  }

  def purgeUnreferencedRuntimeSessionDirs {
    val sfdir = sharedFileDir
    val rsdir = new File(sfdir, "RuntimeSession")
    if (! rsdir.exists) return
    for (f <- rsdir.list) {
      val rsf = new File(rsdir, f)
      if (rsf.isDirectory) {
        try {
          val rid = f.toLong
          if (! models.RuntimeSession.rsExists(rid)) {
            deleteDir(rsf)
          }
        } catch {
          case e: Throwable => {
            println("error: %s".format(e))
          }
        }
      }
    }
  }

  */

  def deleteDir(d: File) {
    if (d.isDirectory) {
      for (fname <- d.list) {
        deleteDir(new File(d, fname))
      }
    }
    d.delete
  }

  def copyFile(inf: File, outf: File) {
    val in = new FileInputStream(inf)
    val out = new FileOutputStream(outf)
    copyStreams(in, out)
    in.close
    out.close
    /*
    val buf = new Array[Byte](1024)
    var len: Int = 0
    len = in.read(buf)
    while(len > 0) {
      out.write(buf, 0, len)
      len = in.read(buf)
    }
    */
  }

  def copyStreams(in: InputStream, out: OutputStream) {
    val buf = new Array[Byte](1024)
    var len: Int = 0
    len = in.read(buf)
    while(len > 0) {
      out.write(buf, 0, len)
      len = in.read(buf)
    }
  }

  private def createGenericTempFile(prefix: String, suffix: String): File = {
    val s = {
      if (suffix.startsWith("."))
        suffix
      else
        "." + suffix
    }
    File.createTempFile(prefix, s, tempDir)
  }

  private lazy val registryFile: File = new File("%s%sNLS_longterm_temp_files.txt".format(tempDir, File.separator))

  private lazy val aRandomIDForThisCurrentJVMProcess: String = Random.string(10)

  def purgeOld {
    purgeOldNDSTempFiles
  }

}
